import asyncio
import json
import sys
import os
from datetime import datetime

# Add parent directory to path to import agent modules
sys.path.append(os.path.join(os.path.dirname(__file__), "../.."))

from agent.recon import run_recon
from agent.analyze import detect_vulns
from agent.exploit import try_sqli
from mcp.browserbase_client import create_session, screenshot
from mcp.github_client import create_pr
from sqlalchemy.orm import Session
from models import PentestRun, Vulnerability, Patch, Target

class PentestWorker:
    """Background worker for running pentests"""

    @staticmethod
    async def run_pentest(run_id: int, db: Session):
        """Execute full pentest for a given run"""
        try:
            # Get run and target
            run = db.query(PentestRun).filter(PentestRun.id == run_id).first()
            if not run:
                return

            target = db.query(Target).filter(Target.id == run.target_id).first()
            if not target:
                run.status = "failed"
                run.error_message = "Target not found"
                db.commit()
                return

            # Update status
            run.status = "running"
            run.started_at = datetime.utcnow()
            db.commit()

            print(f"üöÄ Starting pentest for {target.name} ({target.url})")

            # Phase 1: Recon
            print("üîç Phase 1: Reconnaissance")
            recon_output = await run_recon(target.ip_address or target.url, target.url)
            run.recon_output = recon_output
            db.commit()

            # Phase 2: Analyze
            print("üß† Phase 2: Vulnerability Detection")
            vulns_json = detect_vulns(recon_output)

            # Parse vulnerabilities
            try:
                vulns_data = json.loads(vulns_json.replace("```json", "").replace("```", ""))
                run.vulnerabilities_json = vulns_data
                vulns_list = vulns_data.get("vulnerabilities", [])
            except:
                vulns_list = []

            print(f"Found {len(vulns_list)} vulnerabilities")

            # Phase 3: Exploit and create vulnerability records
            screenshots = []
            patched_files = {}

            for v in vulns_list[:5]:  # Limit to 5 vulns for demo
                print(f"‚öîÔ∏è Processing {v['type']} on {v['endpoint']}")

                # Create vulnerability record
                vuln = Vulnerability(
                    run_id=run_id,
                    type=v['type'],
                    severity=v.get('severity', 'medium'),
                    endpoint=v['endpoint'],
                    param=v.get('param'),
                    description=f"{v['type']} vulnerability detected on {v['endpoint']}"
                )
                db.add(vuln)
                db.flush()

                # Try to exploit
                if v['type'] == "SQLi":
                    try:
                        success, output = await try_sqli(target.url + v['endpoint'], v.get('param', ''))
                        if success:
                            vuln.exploited = True
                            vuln.exploit_output = output[:1000]  # Truncate

                            # Take screenshot proof
                            try:
                                session = create_session()
                                screenshot_url = screenshot(session.session_id, target.url)
                                vuln.proof_url = screenshot_url
                                screenshots.append(screenshot_url)
                            except Exception as e:
                                print(f"Screenshot failed: {e}")

                            # Generate patch (simplified)
                            patch = Patch(
                                vuln_id=vuln.id,
                                file_path=v['endpoint'].replace('/', '_') + ".php",
                                diff="+ mysqli_real_escape_string($link, $input);  // AutoCTF fix",
                                status="pending"
                            )
                            db.add(patch)
                            patched_files[patch.file_path] = "// Patched by AutoCTF\n// TODO: Implement proper input sanitization"
                    except Exception as e:
                        print(f"Exploit failed: {e}")

                db.commit()

            # Phase 4: Create PR if patches exist
            if patched_files:
                print("üîß Phase 4: Creating GitHub PR")
                try:
                    pr_url = create_pr(
                        title=f"[AutoCTF] Security fixes for {target.name}",
                        body=f"Automated security patches for {len(patched_files)} vulnerabilities detected by AutoCTF.\n\nScan ID: {run_id}",
                        branch=f"autoctf-patch-{run_id}",
                        files=patched_files
                    )

                    # Update patches with PR URL
                    for patch in db.query(Patch).join(Vulnerability).filter(Vulnerability.run_id == run_id).all():
                        patch.pr_url = pr_url
                        patch.status = "created"

                    print(f"‚úÖ PR created: {pr_url}")
                except Exception as e:
                    print(f"PR creation failed: {e}")

            # Complete
            run.status = "completed"
            run.completed_at = datetime.utcnow()
            target.last_scan = datetime.utcnow()
            db.commit()

            print(f"‚úÖ Pentest completed for {target.name}")

        except Exception as e:
            print(f"‚ùå Pentest failed: {e}")
            run.status = "failed"
            run.error_message = str(e)
            run.completed_at = datetime.utcnow()
            db.commit()
