import asyncio
import json
import sys
import os
from datetime import datetime

# Add parent directory to path to import agent modules
sys.path.append(os.path.join(os.path.dirname(__file__), "../.."))

from agent.recon import run_recon
from agent.analyze import detect_vulns
from agent.exploit import try_sqli, create_dump_screenshot
from mcp.browserbase_client import create_session, screenshot
from mcp.github_client import create_pr
from sqlalchemy.orm import Session
from models import PentestRun, Vulnerability, Patch, Target

def generate_sqli_patch(endpoint: str, dump_data: dict):
    """Generate a secure patch for SQLi vulnerability with context from exploitation"""

    # Extract info from dump data
    databases_found = ', '.join(dump_data.get('databases', [])) or 'Unknown'
    credentials_found = len(dump_data.get('credentials', []))

    patch_template = f"""<?php
/**
 * SECURITY PATCH - Applied by AutoCTF
 *
 * VULNERABILITY: SQL Injection
 * ENDPOINT: {endpoint}
 * EXPLOITATION CONFIRMED: YES
 * DATABASES ACCESSED: {databases_found}
 * CREDENTIALS EXTRACTED: {credentials_found} entries
 *
 * This file has been patched to prevent SQL injection attacks.
 * All user inputs are now properly sanitized using prepared statements.
 */

// Original vulnerable code has been replaced with secure implementation

function secure_query($conn, $username, $password) {{
    // Use prepared statements to prevent SQLi
    $stmt = $conn->prepare("SELECT * FROM users WHERE username = ? AND password = ?");
    $stmt->bind_param("ss", $username, $password);
    $stmt->execute();
    $result = $stmt->get_result();

    return $result;
}}

// Additional security measures:
// 1. Input validation
function validate_input($input) {{
    // Remove any SQL keywords
    $blocked_patterns = ['UNION', 'SELECT', 'DROP', 'DELETE', 'INSERT', '--', '/*', '*/'];
    foreach ($blocked_patterns as $pattern) {{
        if (stripos($input, $pattern) !== false) {{
            return false;
        }}
    }}
    return true;
}}

// 2. Escape all user inputs
function sanitize_input($input) {{
    return htmlspecialchars(strip_tags(trim($input)), ENT_QUOTES, 'UTF-8');
}}

/**
 * IMMEDIATE ACTIONS REQUIRED:
 * 1. Review this patch and test thoroughly
 * 2. Change all database passwords (they may have been compromised)
 * 3. Audit database access logs
 * 4. Consider implementing WAF rules
 * 5. Enable SQL query logging for monitoring
 *
 * The vulnerability was actively exploited during testing.
 * An attacker had full access to: {databases_found}
 */
?>
"""
    return patch_template


class PentestWorker:
    """Background worker for running pentests"""

    @staticmethod
    async def run_pentest(run_id: int, db: Session):
        """Execute full pentest for a given run"""
        try:
            # Get run and target
            run = db.query(PentestRun).filter(PentestRun.id == run_id).first()
            if not run:
                return

            target = db.query(Target).filter(Target.id == run.target_id).first()
            if not target:
                run.status = "failed"
                run.error_message = "Target not found"
                db.commit()
                return

            # Update status
            run.status = "running"
            run.started_at = datetime.utcnow()
            db.commit()

            # Use GitHub repo URL if available, otherwise use target URL
            target_url = target.github_repo if target.github_repo else target.url
            print(f"ğŸš€ Starting pentest for {target.name} ({target_url})")

            # Phase 1: Recon
            print("ğŸ” Phase 1: Reconnaissance")
            recon_output = await run_recon(target.ip_address or target_url, target_url)
            run.recon_output = recon_output
            db.commit()

            # Phase 2: Analyze
            print("ğŸ§  Phase 2: Vulnerability Detection")
            vulns_json = detect_vulns(recon_output)

            # Parse vulnerabilities
            try:
                vulns_data = json.loads(vulns_json.replace("```json", "").replace("```", ""))
                run.vulnerabilities_json = vulns_data
                vulns_list = vulns_data.get("vulnerabilities", [])
            except:
                vulns_list = []

            print(f"Found {len(vulns_list)} vulnerabilities")

            # Phase 3: Exploit and create vulnerability records
            screenshots = []
            patched_files = {}
            all_dump_data = []  # Store all DB dump data for PR

            for v in vulns_list[:5]:  # Limit to 5 vulns for demo
                print(f"âš”ï¸ Processing {v['type']} on {v['endpoint']}")

                # Create vulnerability record
                vuln = Vulnerability(
                    run_id=run_id,
                    type=v['type'],
                    severity=v.get('severity', 'medium'),
                    endpoint=v['endpoint'],
                    param=v.get('param'),
                    description=f"{v['type']} vulnerability detected on {v['endpoint']}"
                )
                db.add(vuln)
                db.flush()

                # Try to exploit
                if v['type'] == "SQLi":
                    try:
                        print(f"ğŸ¯ Attempting SQLi exploitation with DB dump...")
                        success, dump_data = await try_sqli(target.url + v['endpoint'], v.get('param', ''))

                        if success and isinstance(dump_data, dict):
                            vuln.exploited = True
                            vuln.title = f"SQL Injection on {v['endpoint']}"

                            # Store exploitation summary
                            exploit_summary = dump_data.get('summary', 'SQLi exploited successfully')
                            vuln.exploit_output = exploit_summary[:1000]
                            vuln.proof = f"DB Dump successful - {len(dump_data.get('databases', []))} databases accessed"

                            # Store full dump data in vulnerability record
                            vuln.dump_data = {
                                'databases': dump_data.get('databases', []),
                                'credential_count': len(dump_data.get('credentials', [])),
                                'summary': dump_data.get('summary', ''),
                                'timestamp': datetime.utcnow().isoformat()
                            }

                            # Store full dump data for PR
                            all_dump_data.append(dump_data)

                            print(f"ğŸ’¾ DB Dump successful! Found {len(dump_data.get('databases', []))} databases")

                            # Create HTML visualization and screenshot
                            try:
                                print("ğŸ“¸ Creating dump screenshot...")
                                screenshot_url = await create_dump_screenshot(dump_data, target.url)
                                if screenshot_url:
                                    vuln.proof_url = screenshot_url
                                    screenshots.append(screenshot_url)
                                    print(f"âœ… Screenshot saved: {screenshot_url}")
                            except Exception as e:
                                print(f"âš ï¸ Screenshot creation failed: {e}")

                            # Generate enhanced patch with context
                            patch_content = generate_sqli_patch(v['endpoint'], dump_data)
                            patch = Patch(
                                vuln_id=vuln.id,
                                file_path=v['endpoint'].replace('/', '_') + ".php",
                                diff=patch_content,
                                status="pending"
                            )
                            db.add(patch)
                            patched_files[patch.file_path] = patch_content

                            print(f"âœ… SQLi exploitation complete for {v['endpoint']}")

                    except Exception as e:
                        print(f"âŒ Exploit failed: {e}")
                        import traceback
                        traceback.print_exc()

                db.commit()

            # Phase 4: Create PR if patches exist
            if patched_files:
                print("ğŸ”§ Phase 4: Creating GitHub PR with exploitation evidence")
                try:
                    # Aggregate all dump data
                    combined_dump_data = {
                        'databases': [],
                        'credentials': [],
                        'summary': ''
                    }

                    for dump_data in all_dump_data:
                        combined_dump_data['databases'].extend(dump_data.get('databases', []))
                        combined_dump_data['credentials'].extend(dump_data.get('credentials', []))
                        if dump_data.get('summary'):
                            combined_dump_data['summary'] += dump_data['summary'] + "\n\n"

                    # Remove duplicates
                    combined_dump_data['databases'] = list(set(combined_dump_data['databases']))

                    pr_body = f"""
Automated security patches for **{len(patched_files)} vulnerabilities** detected by AutoCTF.

## ğŸ¯ Scan Details
- **Target**: {target.name} ({target.url})
- **Scan ID**: #{run_id}
- **Vulnerabilities Found**: {len(vulns_list)}
- **Vulnerabilities Exploited**: {len(all_dump_data)}
- **Databases Compromised**: {len(combined_dump_data['databases'])}

## âš ï¸ CRITICAL FINDINGS

This is not just a theoretical vulnerability - **we successfully exploited it and dumped the database**.
Review the exploitation evidence below to understand the severity.
"""

                    pr_url = create_pr(
                        title=f"ğŸš¨ [AutoCTF] CRITICAL: SQLi Patched for {target.name}",
                        body=pr_body,
                        branch=f"autoctf-patch-{run_id}",
                        files=patched_files,
                        screenshots=screenshots,
                        dump_data=combined_dump_data if combined_dump_data['databases'] else None
                    )

                    # Update patches with PR URL
                    for patch in db.query(Patch).join(Vulnerability).filter(Vulnerability.run_id == run_id).all():
                        patch.pr_url = pr_url
                        patch.status = "created"

                    print(f"âœ… PR created with {len(screenshots)} screenshots: {pr_url}")
                except Exception as e:
                    print(f"âŒ PR creation failed: {e}")
                    import traceback
                    traceback.print_exc()

            # Complete
            run.status = "completed"
            run.completed_at = datetime.utcnow()
            target.last_scan = datetime.utcnow()
            db.commit()

            print(f"âœ… Pentest completed for {target.name}")

        except Exception as e:
            print(f"âŒ Pentest failed: {e}")
            run.status = "failed"
            run.error_message = str(e)
            run.completed_at = datetime.utcnow()
            db.commit()
