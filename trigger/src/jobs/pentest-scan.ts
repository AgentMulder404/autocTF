import { eventTrigger } from "@trigger.dev/sdk";
import { client } from "../index";
import axios from "axios";

/**
 * Pentest Scan Job
 *
 * Handles long-running penetration tests that can take 2-10+ minutes
 * Sends progress updates back to Railway backend via webhooks
 *
 * Trigger: Manual via API call from Railway backend
 * Timeout: 30 minutes
 * Retry: 2 attempts with exponential backoff
 */

interface PentestScanPayload {
  runId: number;
  targetId: number;
  targetUrl: string;
  targetIp?: string;
  githubRepo?: string;
  backendUrl: string; // Railway API URL for status updates
  backendApiKey: string; // Auth token for callbacks
}

interface PentestResult {
  runId: number;
  status: "completed" | "failed";
  reconOutput?: string;
  vulnerabilities?: any[];
  errorMessage?: string;
}

client.defineJob({
  id: "pentest-scan",
  name: "Run Penetration Test Scan",
  version: "1.0.0",
  trigger: eventTrigger({
    name: "pentest.scan.start",
  }),
  run: async (payload: PentestScanPayload, io, ctx) => {
    const { runId, targetUrl, githubRepo, backendUrl, backendApiKey } = payload;

    try {
      // Phase 1: Reconnaissance
      await io.logger.info(`[${runId}] Starting reconnaissance phase`);
      await sendProgress(backendUrl, backendApiKey, runId, "running", "Starting reconnaissance...");

      const reconOutput = await io.runTask(
        "run-recon",
        async () => {
          // Call Python agent via subprocess or HTTP
          // For now, we'll call the Railway backend's internal endpoint
          const response = await axios.post(
            `${backendUrl}/internal/run-recon`,
            {
              runId,
              targetUrl: githubRepo || targetUrl,
              targetIp: payload.targetIp,
            },
            {
              headers: { "X-API-Key": backendApiKey },
              timeout: 180000, // 3 minutes
            }
          );
          return response.data.output;
        },
        {
          name: "Reconnaissance Scan",
          params: { targetUrl, githubRepo },
        }
      );

      await io.logger.info(`[${runId}] Recon complete: ${reconOutput.length} chars`);
      await sendProgress(backendUrl, backendApiKey, runId, "running", "Reconnaissance complete, analyzing...");

      // Phase 2: Vulnerability Analysis
      await io.logger.info(`[${runId}] Starting vulnerability analysis`);

      const vulnerabilities = await io.runTask(
        "analyze-vulns",
        async () => {
          const response = await axios.post(
            `${backendUrl}/internal/analyze-vulns`,
            {
              runId,
              reconOutput,
            },
            {
              headers: { "X-API-Key": backendApiKey },
              timeout: 120000, // 2 minutes
            }
          );
          return response.data.vulnerabilities;
        },
        {
          name: "Vulnerability Analysis",
          params: { reconLength: reconOutput.length },
        }
      );

      await io.logger.info(`[${runId}] Found ${vulnerabilities.length} vulnerabilities`);
      await sendProgress(
        backendUrl,
        backendApiKey,
        runId,
        "running",
        `Found ${vulnerabilities.length} vulnerabilities, exploiting...`
      );

      // Phase 3: Exploitation (if vulnerabilities found)
      let exploitResults = [];
      if (vulnerabilities.length > 0) {
        await io.logger.info(`[${runId}] Starting exploitation phase`);

        exploitResults = await io.runTask(
          "exploit-vulns",
          async () => {
            const response = await axios.post(
              `${backendUrl}/internal/exploit-vulns`,
              {
                runId,
                targetUrl,
                vulnerabilities,
              },
              {
                headers: { "X-API-Key": backendApiKey },
                timeout: 300000, // 5 minutes
              }
            );
            return response.data.results;
          },
          {
            name: "Exploitation",
            params: { vulnCount: vulnerabilities.length },
          }
        );

        await io.logger.info(`[${runId}] Exploitation complete`);
      }

      // Phase 4: Mark as complete
      await sendProgress(backendUrl, backendApiKey, runId, "completed", "Pentest complete");

      await io.logger.info(`[${runId}] ✅ Pentest scan completed successfully`);

      return {
        runId,
        status: "completed",
        reconOutput,
        vulnerabilities,
        exploitResults,
      };
    } catch (error: any) {
      await io.logger.error(`[${runId}] ❌ Pentest failed: ${error.message}`);

      // Mark run as failed
      await sendProgress(backendUrl, backendApiKey, runId, "failed", error.message);

      throw error;
    }
  },
});

/**
 * Send progress update to Railway backend
 */
async function sendProgress(
  backendUrl: string,
  apiKey: string,
  runId: number,
  status: string,
  message: string
) {
  try {
    await axios.post(
      `${backendUrl}/internal/scan-progress`,
      {
        runId,
        status,
        message,
        timestamp: new Date().toISOString(),
      },
      {
        headers: { "X-API-Key": apiKey },
        timeout: 10000,
      }
    );
  } catch (error) {
    console.error(`Failed to send progress update:`, error);
    // Don't throw - progress updates are best-effort
  }
}
